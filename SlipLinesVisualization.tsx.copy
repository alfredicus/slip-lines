import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls';
import { LineSegments2 } from 'three/examples/jsm/lines/LineSegments2.js';
import { LineGeometry } from 'three/examples/jsm/lines/LineGeometry.js';
import { LineMaterial } from 'three/examples/jsm/lines/LineMaterial.js';

import {
    generateEquipotentials,
    generateSlipLines,
    generatePrincipalAxes,
    EquipotentialCurve,
    SlipLineCurve,
    PrincipalAxis,
    getEquipotentialPoint,
} from './stressFieldCompute';
import { BufferGeometry, Float32BufferAttribute, Uint32BufferAttribute } from './keplerlit/attributes';
import { createLut } from './keplerlit/colorMap';
import { fromValueToColor, minMax } from './keplerlit/utils';
import { Color } from './keplerlit/Color';

/**
     * Compute S2 (intermediate principal stress) from S1, S3, and stress ratio R
     * 
     * Formula: R = (S2 - S3) / (S1 - S3)
     * Solving for S2: S2 = S3 + R * (S1 - S3)
     * 
     * @param S1 - Minimum principal stress (most compressive)
     * @param S3 - Maximum principal stress (most extensional)
     * @param R - Stress ratio [0, 1]
     * @returns S2 - Intermediate principal stress
     */
const computeS2 = (S1: number, S3: number, R: number): number => {
    return S3 + R * (S1 - S3);
};

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

interface ControlState {
    S1: number;           // Minimum principal stress (most compressive)
    S3: number;           // Maximum principal stress (most extensional)
    R: number;            // Stress ratio: R = (S2-S3)/(S1-S3), between 0 and 1
    showEquipotential: boolean;
    showSlipLines: boolean;
    showStressAxes: boolean;
    slipLineColor: string;
    equipotentialColor: string;
}

// ============================================================================
// CONSTANTS
// ============================================================================

const INITIAL_CONTROLS: ControlState = {
    S1: 1.0,              // Minimum principal stress
    S3: 3.0,              // Maximum principal stress
    R: 0.5,               // Stress ratio (0 to 1)
    showEquipotential: true,
    showSlipLines: true,
    showStressAxes: true,
    slipLineColor: '#D62728',
    equipotentialColor: '#1F77B4'
};

const COMPUTE_CONFIG = {
    nCurves: 12,
    nIsoCurves: 8,
    curveResolution: 500
};

const CAMERA_INITIAL_POS = { x: 3, y: 3, z: 3 };
const SPHERE_OPACITY = 1;
const AXES_SIZE = 0.8;

// ============================================================================
// REACT COMPONENT
// ============================================================================

const SlipLinesVisualization: React.FC = () => {
    // -------------------------------------------------------------------------
    // REFS
    // -------------------------------------------------------------------------

    const containerRef = useRef<HTMLDivElement>(null);
    const sceneRef = useRef<THREE.Scene | null>(null);
    const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
    const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
    const sphereGeometryRef = useRef<THREE.SphereGeometry | null>(null);
    const sphereGroupRef = useRef<THREE.Group>(new THREE.Group());

    // -------------------------------------------------------------------------
    // STATE
    // -------------------------------------------------------------------------

    const [controls, setControls] = useState<ControlState>(INITIAL_CONTROLS);

    // -------------------------------------------------------------------------
    // EVENT HANDLERS
    // -------------------------------------------------------------------------

    const handleControlChange = <K extends keyof ControlState>(
        key: K,
        value: ControlState[K]
    ): void => {
        setControls((prev) => ({ ...prev, [key]: value }));
    };

    // -------------------------------------------------------------------------
    // THREE.JS SCENE INITIALIZATION
    // -------------------------------------------------------------------------

    useEffect(() => {
        if (!containerRef.current) return;

        // Create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaaaaaa);
        sceneRef.current = scene;

        // Create camera
        const width = containerRef.current.clientWidth;
        const height = containerRef.current.clientHeight;
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.set(CAMERA_INITIAL_POS.x, CAMERA_INITIAL_POS.y, CAMERA_INITIAL_POS.z);
        camera.lookAt(0, 0, 0);
        cameraRef.current = camera;

        // Create renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        containerRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        // -----------------------------------------------------------------------
        // LIGHTING
        // -----------------------------------------------------------------------

        const ambientLight = new THREE.AmbientLight(0xffffff, 2);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.99);
        directionalLight1.position.set(5, 5, 5);
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.99);
        directionalLight2.position.set(-5, -5, -5);
        scene.add(directionalLight2);

        // -----------------------------------------------------------------------
        // SPHERE MESH
        // -----------------------------------------------------------------------

        const sphereGeometry = new THREE.SphereGeometry(1, 256, 256);
        sphereGeometryRef.current = sphereGeometry;

        const sphereMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            wireframe: false,
            opacity: SPHERE_OPACITY,
            transparent: true,
            vertexColors: true
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // -----------------------------------------------------------------------
        // COORDINATE AXES HELPER
        // -----------------------------------------------------------------------

        const axesHelper = new THREE.AxesHelper(AXES_SIZE);
        scene.add(axesHelper);

        // Add the group for curves
        scene.add(sphereGroupRef.current);

        // -----------------------------------------------------------------------
        // TRACKBALL CONTROLS
        // -----------------------------------------------------------------------

        const controls = new TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noRotate = false;
        controls.noZoom = false;
        controls.noPan = false;
        controls.autoRotate = false;
        controls.target.set(0, 0, 0);

        // -----------------------------------------------------------------------
        // ANIMATION LOOP
        // -----------------------------------------------------------------------

        let animationId: number;
        const animate = (): void => {
            animationId = requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        };
        animate();

        // -----------------------------------------------------------------------
        // WINDOW RESIZE HANDLER
        // -----------------------------------------------------------------------

        const handleResize = (): void => {
            if (!containerRef.current || !cameraRef.current) return;

            const newWidth = containerRef.current.clientWidth;
            const newHeight = containerRef.current.clientHeight;

            cameraRef.current.aspect = newWidth / newHeight;
            cameraRef.current.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        };

        window.addEventListener('resize', handleResize);

        // -----------------------------------------------------------------------
        // CLEANUP
        // -----------------------------------------------------------------------

        return () => {
            window.removeEventListener('resize', handleResize);

            controls.dispose();
            cancelAnimationFrame(animationId);
            renderer.dispose();

            if (containerRef.current?.contains(renderer.domElement)) {
                containerRef.current.removeChild(renderer.domElement);
            }
        };
    }, []);

    // =========================================================================
    // VISUALIZATION UPDATE - Compute and render curves
    // =========================================================================

    useEffect(() => {
        if (!sphereGroupRef.current) return;

        // Clear previous geometry
        sphereGroupRef.current.clear();

        // -----------------------------------------------------------------------
        // GENERATE AND ADD EQUIPOTENTIALS
        // -----------------------------------------------------------------------

        if (controls.showEquipotential) {
            const S2 = computeS2(controls.S1, controls.S3, controls.R);
            const equipotentials = generateEquipotentials(
                controls.S1,    // lambda_x (sigma1 - minimum/most compressive)
                S2,             // lambda_y (sigma2 - intermediate, computed from R)
                controls.S3,    // lambda_z (sigma3 - maximum/most extensional)
                COMPUTE_CONFIG
            );
            addLinesToScene(equipotentials, controls.equipotentialColor, sphereGroupRef.current);
        }

        // -----------------------------------------------------------------------
        // GENERATE AND ADD SLIP LINES
        // -----------------------------------------------------------------------

        if (controls.showSlipLines) {
            const S2 = computeS2(controls.S1, controls.S3, controls.R);
            const slipLines = generateSlipLines(
                controls.S1,    // lambda_x (sigma1 - minimum/most compressive)
                S2,             // lambda_y (sigma2 - intermediate, computed from R)
                controls.S3,    // lambda_z (sigma3 - maximum/most extensional)
                COMPUTE_CONFIG
            );
            addLinesToScene(slipLines, controls.slipLineColor, sphereGroupRef.current);
        }

        // -----------------------------------------------------------------------
        // GENERATE AND ADD PRINCIPAL STRESS AXES
        // -----------------------------------------------------------------------

        if (controls.showStressAxes) {
            const S2 = computeS2(controls.S1, controls.S3, controls.R);
            const axes = generatePrincipalAxes(
                controls.S1,    // sigma1 - minimum/most compressive
                S2,             // sigma2 - intermediate, computed from R
                controls.S3     // sigma3 - maximum/most extensional
            );
            addAxesToScene(axes, sphereGroupRef.current);
        }

        // ===============================================================================
        // TODO: iso contouring on sphere based on equipotential values
        // Update sphere iso-contours here
        // ===============================================================================
        if (sphereGeometryRef.current) {
            const geom = sphereGeometryRef.current
            const position = geom.attributes.position
            const attribute: THREE.BufferAttribute = geom.getAttribute('equipotentialValue') as THREE.BufferAttribute;
            if (!attribute) {
                const equipotentialValues = new Float32Array(position.count * 3);
                geom.setAttribute('equipotentialValue', new THREE.BufferAttribute(equipotentialValues, 1));
            }
            const equipotentialValues = geom.getAttribute('equipotentialValue') as THREE.BufferAttribute;

            // attr: number[] -> colors: number[] -> update geom colors

            const attr: number[] = []
            for (let i = 0; i < position.count; i++) {
                const x = position.getX(i);
                const y = position.getY(i);
                const z = position.getZ(i);
                const v = getEquipotentialPoint(
                    { x, y, z },
                    controls.S1,
                    computeS2(controls.S1, controls.S3, controls.R),
                    controls.S3
                );
                attr.push(v);
            }
            const mm = minMax(attr)
            const normalizeAttr = (v: number) => (v - mm[0]) / (mm[1] - mm[0])

            const lutTable = createLut("Igeoss", 512)
            lutTable.setMin(mm[0])
            lutTable.setMax(mm[1])

            const colors: number[] = []

            attr.forEach((v, i) => {
                const c = fromValueToColor(normalizeAttr(v), {
                    min: mm[0],
                    max: mm[1],
                    defaultColor: new Color("#ffffff"),
                    lutTable
                })
                colors.push(...c)
            })

            geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3))
            geom.getAttribute("color").needsUpdate = true;

            // Update isos
            const positionsArray = geom.attributes.position.array
            const indicesArray = geom.index?.array

            if (!indicesArray) {
                return
            }

            const keplerPositions = new Float32BufferAttribute(Array.from(positionsArray), 3)
            const keplerIndices = new Uint32BufferAttribute(Array.from(indicesArray), 1)

            const keplerGeometry = new BufferGeometry()
            keplerGeometry.setPositions(keplerPositions)
            keplerGeometry.setIndices(keplerIndices)

            // Calculate contour levels
            // const minVal = Math.min(...scalarField)
            // const maxVal = Math.max(...scalarField)
        }


    }, [
        controls.S1,
        controls.S3,
        controls.R,
        controls.showEquipotential,
        controls.showSlipLines,
        controls.showStressAxes,
        controls.slipLineColor,
        controls.equipotentialColor
    ]);

    // =========================================================================
    // HELPER FUNCTIONS - THREE.JS GEOMETRY CREATION
    // =========================================================================

    /**
     * Add curve lines to the Three.js scene
     * Handles both equipotential curves and slip lines
     */
    const addLinesToScene = (
        curves: EquipotentialCurve[] | SlipLineCurve[],
        color: string,
        group: THREE.Group
    ): void => {
        (curves as any[]).forEach((curve) => {
            // Extract coordinates from curve
            const x = (curve as any).x || [];
            const y = (curve as any).y || [];
            const z = (curve as any).z || [];

            if (x.length === 0 || y.length === 0 || z.length === 0) return;
            if (x.length !== y.length || y.length !== z.length) return;

            // Create Three.js geometry
            const geometry = new THREE.BufferGeometry();
            const positions: number[] = [];

            for (let i = 0; i < x.length; i++) {
                positions.push(x[i], y[i], z[i]);
            }

            geometry.setAttribute(
                'position',
                new THREE.BufferAttribute(new Float32Array(positions), 3)
            );

            // Create material and line
            // const material = new THREE.LineBasicMaterial({
            //     color: new THREE.Color(color),
            //     fog: false
            // });

            // const lineObj = new THREE.Line(geometry, material);
            const lineGeometry = new LineGeometry().setPositions(positions);
            const lineMaterial = new LineMaterial({
                color: new THREE.Color(color),
                linewidth: 5,
                resolution: new THREE.Vector2(1, 1)
            });
            const lineObj = new LineSegments2(lineGeometry, lineMaterial);
            group.add(lineObj);
        });
    };

    /**
     * Add principal stress axes to the scene with arrow heads
     */
    const addAxesToScene = (axes: PrincipalAxis[], group: THREE.Group): void => {
        axes.forEach((axis) => {
            // ---------------------------------------------------------------
            // MAIN AXIS LINE
            // ---------------------------------------------------------------

            const geometry = new THREE.BufferGeometry();
            const positions = [
                0, 0, 0,
                axis.axis.x * 1.5, axis.axis.y * 1.5, axis.axis.z * 1.5
            ];

            geometry.setAttribute(
                'position',
                new THREE.BufferAttribute(new Float32Array(positions), 3)
            );

            const material = new THREE.LineBasicMaterial({
                color: axis.colorHex,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
            });
            const line = new THREE.Line(geometry, material);
            group.add(line);

            // ---------------------------------------------------------------
            // ARROW HEAD
            // ---------------------------------------------------------------

            const arrowDir = new THREE.Vector3(axis.axis.x, axis.axis.y, axis.axis.z).normalize();
            const arrowLength = 0.2;
            const arrowOrigin = new THREE.Vector3(
                axis.axis.x * 1.5,
                axis.axis.y * 1.5,
                axis.axis.z * 1.5
            );

            // Get perpendicular vectors for arrow wings
            let perpDir1 = new THREE.Vector3()
                .crossVectors(arrowDir, new THREE.Vector3(0, 0, 1))
                .normalize();

            if (perpDir1.length() === 0) {
                perpDir1.set(1, 0, 0);
            }

            const perpDir2 = new THREE.Vector3()
                .crossVectors(arrowDir, perpDir1)
                .normalize();

            // Create arrow head geometry
            const arrowGeometry = new THREE.BufferGeometry();
            const arrowPositions = [
                // First wing
                arrowOrigin.x, arrowOrigin.y, arrowOrigin.z,
                arrowOrigin.x - arrowDir.x * arrowLength + perpDir1.x * arrowLength * 0.3,
                arrowOrigin.y - arrowDir.y * arrowLength + perpDir1.y * arrowLength * 0.3,
                arrowOrigin.z - arrowDir.z * arrowLength + perpDir1.z * arrowLength * 0.3,
                // Second wing
                arrowOrigin.x, arrowOrigin.y, arrowOrigin.z,
                arrowOrigin.x - arrowDir.x * arrowLength + perpDir2.x * arrowLength * 0.3,
                arrowOrigin.y - arrowDir.y * arrowLength + perpDir2.y * arrowLength * 0.3,
                arrowOrigin.z - arrowDir.z * arrowLength + perpDir2.z * arrowLength * 0.3
            ];

            arrowGeometry.setAttribute(
                'position',
                new THREE.BufferAttribute(new Float32Array(arrowPositions), 3)
            );

            const arrow = new THREE.LineSegments(arrowGeometry, material);
            group.add(arrow);
        });
    };

    // =========================================================================
    // RENDER
    // =========================================================================

    return (
        <div style={{ display: 'flex', height: '100vh', fontFamily: 'Arial, sans-serif' }}>
            {/* 3D Visualization */}
            <div
                ref={containerRef}
                style={{
                    flex: 1,
                    position: 'relative'
                }}
            />

            {/* Control Panel */}
            <ControlPanel controls={controls} onControlChange={handleControlChange} />
        </div>
    );
};

// ============================================================================
// CONTROL PANEL COMPONENT
// ============================================================================

interface ControlPanelProps {
    controls: ControlState;
    onControlChange: <K extends keyof ControlState>(key: K, value: ControlState[K]) => void;
}

const ControlPanel: React.FC<ControlPanelProps> = ({ controls, onControlChange }) => {
    return (
        <div
            style={{
                width: 350,
                padding: 20,
                backgroundColor: '#f5f5f5',
                borderLeft: '1px solid #ddd',
                overflowY: 'auto'
            }}
        >
            <h2 style={{ marginTop: 0, fontSize: 18, fontWeight: 'bold' }}>
                3D Slip Lines & Equipotentials
            </h2>

            {/* Stress Tensor Parameters Section */}
            <div style={{ marginBottom: 25 }}>
                <h3 style={{ fontSize: 14, fontWeight: 'bold', marginBottom: 12 }}>
                    Principal Stresses
                </h3>

                <StressSlider
                    label="S₁ (σ₁ - minimum)"
                    value={controls.S1}
                    onChange={(val) => onControlChange('S1', val)}
                    min={-5}
                    max={5}
                    step={0.1}
                />

                <StressSlider
                    label="S₃ (σ₃ - maximum)"
                    value={controls.S3}
                    onChange={(val) => onControlChange('S3', val)}
                    min={-5}
                    max={5}
                    step={0.1}
                />

                <div style={{ marginBottom: 15 }}>
                    <label style={{ display: 'block', marginBottom: 5, fontSize: 13 }}>
                        R (stress ratio): {controls.R.toFixed(2)}
                    </label>
                    <input
                        type="range"
                        min="0"
                        max="1"
                        step="0.01"
                        value={controls.R}
                        onChange={(e) => onControlChange('R', parseFloat(e.target.value))}
                        style={{ width: '100%', cursor: 'pointer' }}
                    />
                    <small style={{ color: '#999', fontSize: 11 }}>
                        R = (S₂ - S₃) / (S₁ - S₃), where S₂ = {computeS2(controls.S1, controls.S3, controls.R).toFixed(3)}
                    </small>
                </div>
            </div>

            {/* Visualization Options Section */}
            <div style={{ marginBottom: 25 }}>
                <h3 style={{ fontSize: 14, fontWeight: 'bold', marginBottom: 12 }}>
                    Visualization
                </h3>

                <ToggleControl
                    label="Show Equipotentials"
                    checked={controls.showEquipotential}
                    onChange={(val) => onControlChange('showEquipotential', val)}
                >
                    <ColorPicker
                        value={controls.equipotentialColor}
                        onChange={(val) => onControlChange('equipotentialColor', val)}
                    />
                </ToggleControl>

                <ToggleControl
                    label="Show Slip Lines"
                    checked={controls.showSlipLines}
                    onChange={(val) => onControlChange('showSlipLines', val)}
                >
                    <ColorPicker
                        value={controls.slipLineColor}
                        onChange={(val) => onControlChange('slipLineColor', val)}
                    />
                </ToggleControl>

                <ToggleControl
                    label="Show Stress Axes"
                    checked={controls.showStressAxes}
                    onChange={(val) => onControlChange('showStressAxes', val)}
                />
            </div>

            {/* Info Section */}
            <div style={{
                fontSize: 12,
                color: '#666',
                borderTop: '1px solid #ddd',
                paddingTop: 15
            }}>
                <p style={{ margin: '0 0 8px 0', fontWeight: 'bold' }}>Controls:</p>
                <ul style={{ margin: 0, paddingLeft: 16, lineHeight: 1.6 }}>
                    <li>Left drag: Rotate</li>
                    <li>Middle drag: Zoom</li>
                    <li>Right drag: Pan</li>
                    <li>Scroll: Zoom</li>
                </ul>
            </div>
        </div>
    );
};

// ============================================================================
// UI CONTROL COMPONENTS
// ============================================================================

interface StressSliderProps {
    label: string;
    value: number;
    onChange: (value: number) => void;
    min?: string | number;
    max?: string | number;
    step?: string | number;
}

const StressSlider: React.FC<StressSliderProps> = ({
    label,
    value,
    onChange,
    min = "-5",
    max = "5",
    step = "0.1"
}) => (
    <div style={{ marginBottom: 15 }}>
        <label style={{ display: 'block', marginBottom: 5, fontSize: 13 }}>
            {label}: {value.toFixed(2)}
        </label>
        <input
            type="range"
            min={min}
            max={max}
            step={step}
            value={value}
            onChange={(e) => onChange(parseFloat(e.target.value))}
            style={{ width: '100%', cursor: 'pointer' }}
        />
    </div>
);

interface ToggleControlProps {
    label: string;
    checked: boolean;
    onChange: (checked: boolean) => void;
    children?: React.ReactNode;
}

const ToggleControl: React.FC<ToggleControlProps> = ({ label, checked, onChange, children }) => (
    <>
        <div style={{ marginBottom: 12 }}>
            <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: 13 }}>
                <input
                    type="checkbox"
                    checked={checked}
                    onChange={(e) => onChange(e.target.checked)}
                    style={{ marginRight: 8, width: 16, height: 16, cursor: 'pointer' }}
                />
                <span>{label}</span>
            </label>
        </div>
        {checked && children && <div style={{ marginBottom: 12, paddingLeft: 24 }}>{children}</div>}
    </>
);

interface ColorPickerProps {
    value: string;
    onChange: (value: string) => void;
}

const ColorPicker: React.FC<ColorPickerProps> = ({ value, onChange }) => (
    <label style={{ display: 'flex', alignItems: 'center', gap: 8, fontSize: 13 }}>
        Color:
        <input
            type="color"
            value={value}
            onChange={(e) => onChange(e.target.value)}
            style={{ width: 40, height: 30, cursor: 'pointer', border: 'none' }}
        />
    </label>
);

export default SlipLinesVisualization;